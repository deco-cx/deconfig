# Dynamic edge configuration management

`deconfig` is an **edge-native** deno configuration management framework for building fast and personalized edge applications that can be dynamically configured at runtime without a redeploy.

Applications developers integrate `deconfig` to allow business users to change the configuration of distributed edge systems safely, with full auditability and rollback capability.

`deconfig` allows configuration to be distributed in a precise and deliberate fashion by giving developers granular, function-based control over which configuration is active for any given request.

Developers define `matcher functions` to determine which configuration is active for a given request, and an `effect function` to determine the value of a configuration variable for a given request upon activation.

Once all available configuration for this site is matched, the application can use the final configuration values to determine and run the business logic for the request, be it rendering an HTML response generated by a [fresh](https://fresh.deno.dev) app, executing a [durable](https://github.com/deco-cx/durable) workflow, or any other custom-defined, deno-powered behavior.

## Use cases

There are multiple use cases for `deconfig`, for example:

- **Acess token and secret management**

  - `deconfig` allows developers to distribute access tokens and secrets to running deno applications without exposing them in source code, while allowing for different tokens to be used in different environments.

- **Personalization and A/B testing**

  - `deconfig` allows developers to use configuration to personalize the experience for each user, and measure the impact of each version on user behaviour by tracking the active configurations for each request.

- **Configuration as code**

  - `deconfig` allows developers to express strongly-typed schemas for their application configuration using TypeScript and leverage a rich set of tools (including full auto-generated web editor) to manage and deploy configuration changes.

## Getting started

To start using `deconfig`, you need to import the `deconfig` module and initialize it with a configuration schema and a storage. For this example, we will use the managed storage by `deco.cx`. If you don't have an ID, create a free account at [deco.cx](https://deco.cx) and create a new site.

```typescript
// deco.ts
import { deconfig, deco } from "https://deno.land/x/deconfig/mod.ts";

// Exporting your configuration schema automatically generates a web editor at config.deco.cx/{id}
export type Config = {
  VTEX: {
    account: string;
    token: string;
  };
  Shopify: {
    account: string;
    token: string;
  };
};

// Get current configuration from deco.cx
const config = await deconfig(deco({ id: `YOUR_ID` }));

// Returns the string configured in the web editor at config.deco.cx/{id}
console.log(config.VTEX.account); 
```

From now on, whenever a user changes the value of `VTEX.account` in the `deconfig` web editor, the value of `config.VTEX.account` will be updated automatically in all running instances of your application across the deno deploy platform. Congratulations, you just declared your first globally distributed, edge-native configuration!

Of course, it get's more interesting. Let's say you want to use different tokens for different environments. You can do that by defining a `matcher function` that returns `true` if the current environment matches the one you want to use the configuration for.

## Matcher functions

`deconfig` allows you to define `matcher functions` that determine which configuration is active for a given request. A `matcher function` is a function that takes a `Request` object and returns a boolean. If the function returns `true`, the configuration is active for the request. If the function returns `false`, the configuration is not active for the request.

```typescript
// TODO
```

## Effect functions

// TODO

```typescript
// deco.ts
import { deconfig, deco, Handler } from "https://deno.land/x/deconfig/mod.ts";

export type Config = {
  fresh: {
    routes: Record<string, {handler: Handler, props: any}>;
  };
};

// Get current configuration from deco.cx
const config = await deconfig(deco({ id: `YOUR_ID` }));

// TODO request handler example, use request path to get config and run handler
const routeId = "home";

config.fresh.routes[routeId].handler(config.fresh.routes[routeId].props);
```

## Self-hosting

We are working to make the `deconfig` service available as a self-contained docker image for self-hosting by Q2 2023. In the meantime, you can use our hosted version at [deco.cx](https://deco.cx).

## The deco.cx platform

`deconfig` is part of the `deco.cx` platform, which is a set of tools and services that allow developers to build and deploy edge-native, high-performance commerce experiences. All deco.cx sites are built with `deconfig`, so you can use it in production today. Our free plan is perfect for small projects.
